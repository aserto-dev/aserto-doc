---
sidebar_label: Policy Lifecycle
title: Overview - Policy Lifecycle
description: The Aserto Policy Lifecycle - an Overview
---

# Policy Lifecycle

## Policy

At the core of Asertoâ€™s authorization model is an authorization policy, which we refer to simply as a **Policy**. Policies are authored in a textual language called [Rego](https://www.openpolicyagent.org/docs/latest/policy-language/), defined as part of the [Open Policy Agent](https://www.openpolicyagent.org/) (OPA) project in the [Cloud Native Computing Foundation](https://www.cncf.io/).

Policies are treated just like application code or infrastructure-as-code - they can be stored as code in a git repository, or as an OCIv2 image in a policy repository (like the Aserto Policy Container Registry or the [Open Policy Registry](https://www.openpolicyregistry.io/)).

## The policy lifecycle

Policies are **authored** using a text / code editor, **built** into an image, **published** to a repository hosted on a registry, **run** in a policy instance, and **consumed** by an application.

![Policy as code](/policy-as-code.png)

Aserto's control plane helps manage the policy lifecycle.

### Author

Policies are comprised of a collection of `.rego` files and `.json` files, which provide static data that can be part of the policy.

### Build, tag and publish Policy images

The set of source files that comprise a policy are built into a **Policy Image** using a set of tools that are modeled after the `docker` toolset. You can build and tag a policy just like you build and tag a docker image.

There are two paths for managing the lifecycle of a policy image:

1. Using the `policy` CLI to build, tag and push a policy image to a policy registry.
2. Using GitHub, a **build action** automatically builds a new version of a policy image when the source repository is **tagged** with a new tag.

### `policy` CLI

#### Login

```bash
policy login -s <PATH-TO-REGISTRY> -u <USERNAME> -p <APCR_API_KEY>
```

To connect to the Aserto Container Registry, use the path `registry.prod.aserto.com`.
The APCR API Key is found in the Connections tab under the "apcr" connection:

<img src="/apcr-api-key-copy.png" />

#### Build

To build a policy image, use the `policy build` command. Then, tag your built image by using the `policy tag` command.

```bash
policy build . -t my-org/my-policy:v0.1.2
policy tag my-org/my-policy:v0.1.2 my-org/my-policy:latest
```

#### Publish

To publish a built policy image to the policy registry, use the `policy push` command:

```bash
policy push my-org/my-policy:v0.1.2
```

#### Pull

Using the `policy` CLI, you can pull a policy image from a Policy Repository just like you pull a docker image.

```bash
policy pull my-org/my-policy:v0.1.2
```

### GitHub Actions

Policy repositories generated by Aserto include Github Actions which automatically build and push new policy images to the Aserto Container Registry when a new tag is pushed to the repository.

```bash
git commit -am 'new policy version'
git tag v0.1.2 && git push --tags
```

---

**Manual Setup for GitHub Actions**

In order to set up GitHub Actions manually, use the `policy` CLI and run the following command to initialize a new policy repository:

```bash
policy templates apply github-policy-ci
```

Initially you'll have to select the policy repository you'd like to use:

```bash
  #  SERVER
  1  opcr.io
  2  registry.prod.aserto.com

> Select server#:
```
Select the `registry.prod.aserto.com` server. Next, provide your GitHub username, for example:

```bash
> user (): rschwabco
```
Next, you'll be asked to provide the _name_ of the GitHub secret that will be used to push the policy image to the registry.

```bash
> secret name (TOKEN):
```
Use the name `ASERTO_PUSH_KEY` (this name is used by the Aserto console as well, and would make it easier to allow the workflow to work with the console if you eventually choose to do so). Note that you'll need to use this secret name when you create the secret in your GitHub repository.

Finally, you'll be asked to provide the GitHub organization and repository you'll be using. For example:

```bash
> org/repo: rschwabco/policy-test
```

Once completed, the CLI will generate a `.github` folder which will include the workflow file required to build and push policy changes to the Aserto Container Registry whenever a new tag is pushed to the GitHub repository.

To complete the setup, head to the Aserto console and retrieve the Aserto Policy Registry API key. Head to the Connections tab, and click on "Aserto Policy Registry".

<img src="/apcr-api-key.png" />

Copy the API key, and head to the GitHub repository you just created. In the GitHub repository, click on the "Settings" tab, click on "Secrets" and then select the "Actions" tab. Create a new secret with the same secret name you set (e.g., "TOKEN") and paste the APCR API key as its value.

<img src="/github-action-secret.png" />

Click on "Add secret" to save the secret. Your GitHub repository is now ready to push policy changes to the Aserto Policy Registry.

### Run

To run a policy, you need to create a **policy instance** which is an instance of the decision engine's runtime associated with a tagged version of a policy. You can create multiple policy instances, each associated with a different version of a policy.

To create a policy instance, open the "Policies" tab in the Aserto console, and click "Create an instance":

<img src="/create-instance-button.png" width="170" />

Next, you'll be prompted to select a policy registry:

<img src="/select-policy-registry.png" width="500px" />

Select the policy registry you'd like to use from the dropdown.

Then, you'll be prompted to select a Policy organization. Choose the organization under which you created your repository.

<img src="/select-policy-organization.png" width="500px" />

Next, select the policy repository you want to associate with the policy instance.

<img src="/select-policy-repository.png" width="500px" />

Select the tag you'd like to associate with the policy instance.

<img src="/select-policy-tag.png" width="500px" />

Finally, name your policy instance and click "Create an instance".

<img src="/name-policy-instance.png" width="500px" />

### Consume

An application that wants to authorize a user's access to a resource based on the policy can call the policy instance, passing it the policy, decision(s), user context, and resource context, and the policy instance will evaluate the policy with the provided inputs and returns the boolean value(s) of the requested decision(s), allowing the application to definitively check whether the user has access to the resource based on the given policy.

The [`authz.is`](/docs/authorizer-guide/is) API is the underlying mechanism for an application to call the
policy instance to make a decision. The [language SDKs](/docs/software-development-kits/overview) provide higher-level abstractions for interacting with policy instances.
